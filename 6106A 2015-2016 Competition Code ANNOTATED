/* This code is automatically generated by ROBOTC based upon the motor and sensor setup GUI
The pragma statement (going argument by argument) says
1. What's being configured, a sensor or a motor
2. What port is the sensor or motor plugged into (port for motors, dgtl for digital ports, in for analog)
3. What did the programmer name that motor/sensor
4. What type of sensor/motor is it
5.
6. Either left blank, or input as reversed (whether to reverse motor calls in the code)
Used so that if setting a motor value to 127 actually makes it go backwards, we adjust
the code so that 127 always goes forwards (that way we do not have confusing negative signs around)
7. Whether that motor has an encoder port
8. What encoder port measures that motor
*/

#pragma config(Sensor, dgtl1,  flywheelLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  flywheelRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  flywheelLED,    sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  driveLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  driveRightEncoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           waterwheel,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveTrainLeft, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl6)
#pragma config(Motor,  port3,           flywheelLeft1, tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           flywheelLeft2, tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port5,           rampLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rampRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           flywheelRight1, tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port8,           flywheelRight2, tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port9,           driveTrainRight, tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl8)
#pragma config(Motor,  port10,          shooterConveyor, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//More ROBOTC Generated code that sets up our robot for competition switch control

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)		//autonomous lasts 15 seconds
#pragma userControlDuration(105)	//driver control lasts 105 seconds

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


/* Below are our own #includes, lets us include code from different files
You can see here that we're using Jason McKinney's PID control loop and gyro PID Loop
We have very slightly modified these (syntax error) for our use.
*/

#include "PIDController.h" //CREDIT TO: JMMcKinneyWPI on Github, Jason McKinney for his PID control loop
#include "gyro.c" //CREDIT TO: JMMcKinneyWPI on Github, Jason McKinney for his gyro PID loop

/* Below are some structs that we have created. These are PID structs
(defined in PIDController.h) which we use for PID Loop control
*/

PID flywheelL, flywheelR; //The two pid structs to be monitored and used
PID gyroPid;
PID drivePidL, drivePidR;

// Before pre-autonomous, we define the user functions we will be using

//Power left flywheel
void driveFlywheelLeft(int output)
{
	motor[flywheelLeft1] = output;
	motor[flywheelLeft2] = output;
}

//Power right flywheel
void driveFlywheelRight(int output)
{
	motor[flywheelRight1] = output;
	motor[flywheelRight2] = output;
}

//Power left drive motors (used with Jason McKinney's GyroPID code)
void driveL(int val)
{
	if(abs(val) > 127)
		val = 127 * val/abs(val);

	motor[driveTrainLeft] = val;
}

//Power right drive motors (used with Jason McKinney's GyroPID code)
void driveR(int val)
{
	if(abs(val) > 127)
		val = 127 * val/abs(val);

	motor[driveTrainRight] = val;
}

//The user function for driving straight with a PID loop
void pidDrive(float target) //CREDIT Jason McKinney (modified gyroTurn for pidDrive)

{
	/*These two statements are what we tune during PID Loop tuning
	there's 1 for each drive train side, and pidInit is a function in
	PIDController.h
	to tune, we specify which PID Struct we are tuning (declared above)
	Then, each of first 3 arguments is a constant. First, kP, then kI, last KD
	After those 3 there is 1 more term, epsilon.
	Epsilon is used similar to an integral cap, and will stop summing the
	error once your are in range of the setpoint. The value you choose for
	epsilon tells the controller what range it will stop summing error within
	(so 1 degree off of target, 2, etc.).
	*/

	pidInit(drivePidL, 1.1, 0.015, 0.2, 1);
	pidInit(drivePidR, 1.1, 0.015, 0.2, 1);

	//resetting the motor encoders
	resetMotorEncoder(driveTrainLeft);
	resetMotorEncoder(driveTrainRight);

	//setting variables we'll use later
	bool atDestination = false;
	long atTargetTime = nPgmTime;
	long timer = nPgmTime;
	float degreesTravelledL = 0;
	float degreesTravelledR = 0;

	while(!atDestination)
	{
		//Calculate the delta time from the last iteration of the loop
		float dT = (float)(nPgmTime - timer)/1000;

		//Calculate the current degrees travelled
		degreesTravelledL = getMotorEncoder(driveTrainLeft);
		degreesTravelledR = getMotorEncoder(driveTrainRight);

		//Outputting the current degrees travelled on the right side for debug and graphing/logging purposes
		writeDebugStreamLine("%f", degreesTravelledR);

		//Reset loop timer
		timer = nPgmTime;

		//Calculate the output of the PID controller and output to drive motors
		//The pidExecute function is in PIDController.h
		float driveOutL = pidExecute(drivePidL, degreesTravelledL, target);
		float driveOutR = pidExecute(drivePidR, degreesTravelledR, target);
		driveL(driveOutL);
		driveR(driveOutR);

		//Calculate the error (how far from target)
		float errorL = (float)target - degreesTravelledL;
		float errorR = (float)target - degreesTravelledR;

		//Stop the drive function when the degrees travelled has been within 7 degrees of the desired angle for 350ms
		if(abs(errorL) > 7 && abs(errorR) > 7)
		{
			atTargetTime = nPgmTime;
		}
		if(nPgmTime - atTargetTime > 350)
		{
			atDestination = true;
			driveL(0);
			driveR(0);
		}
	}
}


//Gyro turn to target angle CREDIT Jason McKinney
void gyroTurn(float target) //DO NOT USE GYRO TURNS LESS THAN 20 degrees
{

	/*These pidInit statements are what we tune during PID Loop tuning
	there's 1 for various differnt target ranges. pidInit is a function in
	PIDController.h
	To tune, we specify which PID Struct we are tuning (declared above)
	Then, each of first 3 arguments is a constant. First, kP, then kI, last KD
	After those 3 there is 1 more term, epsilon.
	Epsilon is used similar to an integral cap, and will stop summing the
	error once your are in range of the setpoint. The value you choose for
	epsilon tells the controller what range it will stop summing error within
	(so 1 degree off of target, 2, etc.).
	*/

	//various gyro pid "ranges" Different pid constants handle different degree turns better/worse (without integral).
	if(abs(target) >= 80 )
	{
		pidInit(gyroPid, 3.2, 0, 0.11, 3);
	}
	if(abs(target) > 40 && abs(target) < 80 )
	{
		pidInit(gyroPid, 3.45, 0, 0.08, 3);
	}

	if(abs(target) <= 40 && abs(target) > 25 )
	{
		pidInit(gyroPid, 3.9, 0, 0.05, 3);
	}
	if(abs(target) <= 25 && abs(target) > 20 )
	{
		pidInit(gyroPid, 4.2, 0, 0.03, 3);
	}
	if(abs(target) <= 20 && abs(target) > 17 )
	{
		pidInit(gyroPid, 4.5, 0, 0.01, 3);
	}

	//setting variables we'll use later
	bool atGyro = false;
	long atTargetTime = nPgmTime;
	long timer = nPgmTime;

	//resetting the gyro angle
	gyroResetAngle();

	while(!atGyro)
	{
		//Calculate the delta time from the last iteration of the loop
		float dT = (float)(nPgmTime - timer)/1000;

		//Calculate the current angle of the gyro
		float angle = gyroAddAngle(dT);

		//Outputting the current degrees turned for debug and graphing/logging purposes
		writeDebugStreamLine("%f", angle);

		//Reset loop timer
		timer = nPgmTime;

		//Calculate the output of the PID controller and output to drive motors
		float driveOut = pidExecute(gyroPid, angle, target);
		driveL(-driveOut);
		driveR(driveOut);

		//Calculate the error (how far from target)
		float error = (float)target - angle;

		//Stop the turn function when the angle has been within 3 degrees of the desired angle for at least 350ms
		if(abs(error) > 3)
		{
			atTargetTime = nPgmTime;
		}
		if(nPgmTime - atTargetTime > 350)
		{
			atGyro = true;
			driveL(0);
			driveR(0);
		}
	}
//Reinitialize the PID constants to their original values in case they were changed
pidInit(gyroPid, 3.2, 0, 0.11, 3);
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

//	bStopTasksBetweenModes = false;

// All activities that occur before the competition starts
// Example: clearing encoders, setting servo positions, ...

void pre_auton()
{

	//CREDIT TO: JMMcKinneyWPI on Github, Jason McKinney for his gyro PID loop
	gyroSetPort(in1);

	//Allow gyro to settle and then calibrate (about 3 seconds overall)
	//Do not move or shake the robot during calibration (avoid vibration as well)
	delay(1100);
	//The line below shows using an LED to indicate calibration is in process
	//	SensorValue[calibrationInProgress] = 1;

	gyroCalibrate();
	//	SensorValue[calibrationInProgress] = 0;

	/*Initialize PID controller for gyro
	 * kP = 3.1, kI = 0, kD = 0.11
	 * epsilon = 3,
	*/
	pidInit(gyroPid, 3.1, 0, 0.11, 3);
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

//Setting variables we'll use later

//Average RPM of each flywheel side
float rpmAvgL = 0;
float rpmAvgR = 0;

float dT; //delta T in seconds
float outL, outR;

//Our setpoint for the flywheels (target RPM)
float sp = 1575;

bool set = false;


task autonomous()
{
	//Clearing one of the Cortex's onboard timers for later use
	clearTimer(T1);

	/*These pidInit statements are what we tune during PID Loop tuning
	there's 1 for each flywheel side. pidInit is a function in
	PIDController.h
	To tune, we specify which PID Struct we are tuning (as declared above)
	Then, each of first 3 arguments is a constant. First, kP, then kI, last KD
	After those 3 there is 1 more term, epsilon.
	Epsilon is used similar to an integral cap, and will stop summing the
	error once your are in range of the setpoint. The value you choose for
	epsilon tells the controller what range it will stop summing error within
	(so 1 RPM off of target, 2, etc.).
	*/
	pidInit(flywheelL, 0.3, 0.1, -0.00007, 3);	//NEW NEW BEST
	pidInit(flywheelR, 0.3, 0.1, -0.00007, 3);	//NEW NEW BEST

	unsigned long lastTime = nPgmTime;
	resetMotorEncoder(flywheelLeft1);
	resetMotorEncoder(flywheelRight1);
	bool runFlywheel = false;
	bool btn8DPressed = false;
	float rpmL, lastRpmL1, lastRpmL2, lastRpmL3, lastRpmL4;
	float rpmR, lastRpmR1, lastRpmR2, lastRpmR3, lastRpmR4;
	int counter = 0;

	//The while loop automous will run within (there for the PID Loop)
	while(1==1)
	{
		dT = (float)(nPgmTime - lastTime)/1000; //delta time
		lastTime = nPgmTime;

		if(dT != 0) //if time since our last reading is not 0
		{
			/*RPM Calculation
			The 7 is for an external gear ratio of 7:1 not being measured by the encoder
			/the encoder is attached to the gear right before the flywheel shaft at a
			7:1 ratio).
			The 60 is for 60 seconds in a minute (converts from rotations per second to per minute)
			We get the motor encoder current reading (so ticks since our last reset)
			We divide the ticks since last reset by the change in time since our last reading
			This gets us the number of ticks per second
			We divide the ticks per second by 360 (360 ticks per rotation) to get
			roatations per second
			*/
			//(internal gearing is handled by the /dT)
			rpmL = 7.00*60.00(((float)getMotorEncoder(flywheelLeft1))/dT)/360;
			rpmR = 7.00*60.00(((float)getMotorEncoder(flywheelRight1))/dT)/360;
		}
		else
		{
			rpmL = 0;
			rpmR = 0;
		}
		resetMotorEncoder(flywheelLeft1);
		resetMotorEncoder(flywheelRight1);

		//calculating the average RPM for each flywheel by using the last few readings
		lastRpmL4 = lastRpmL3;
		lastRpmL3 = lastRpmL2;
		lastRpmL2 = lastRpmL1;
		lastRpmL1 = rpmL;

		lastRpmR4 = lastRpmR3;
		lastRpmR3 = lastRpmR2;
		lastRpmR2 = lastRpmR1;
		lastRpmR1 = rpmR;

		rpmAvgL = (rpmL + lastRpmL1 + lastRpmL2 + lastRpmL3 + lastRpmL4)/5;
		rpmAvgR = (rpmR + lastRpmR1 + lastRpmR2 + lastRpmR3 + lastRpmR4)/5;

		//checking if the average RPM is within our desired range
		//increment our "stability" counter if so
		if(rpmAvgR >= sp-75 && rpmR <= sp+75 && rpmAvgL >= sp-75 && rpmL< sp+75)
		{
			counter++;
		}
		//if our "stability" counter has proven stable (is >=3) turn an LED on to
		//indicate flywheel is ready for firing!
		if(counter >= 3)
		{
			SensorValue(flywheelLED) = 1;	//FIRE!!!
		}
		//if our stability counter is out of the range, counter is 0 (not stable)
		//turn flywheelLED off
		if(rpmAvgR < sp-150 || rpmR > sp+150 || rpmAvgL < sp-150 || rpmL > sp+150)
		{
			counter = 0;
			SensorValue(flywheelLED) = 0;
		}

		//integral cap  (keeps it capped at or below a value to keep it from sprialing
		//out of control)
		//THIS WON'T BE NEEDED FOR DOING DRIVING PID, only in use here becuase
		//This PID Loop is constantly running while the flywheel is going
		if(flywheelL.errorSum > 18000)
		{
			flywheelL.errorSum = 18000;
		}
		if(flywheelR.errorSum > 18000)
		{
			flywheelR.errorSum = 18000;
		}

		//set the output value for the left and right flywheel motors (outL) to
		//value calculated by the PID loop
		outL = pidExecute(flywheelL, rpmAvgL, sp);
		outR = pidExecute(flywheelR, rpmAvgR, sp);

		//minimum motor speed
		if(outL < 1)
		{
			outL = 1;
		}
		//drive the left flywheel motors at the value calculated by the PID loop
		driveFlywheelLeft(outL);

		//minimum motor speed
		if(outR < 1)
		{
			outR = 1;
		}
		//drive the right flywheel motors at the value calculated by the PID loop
		driveFlywheelRight(outR);

		//after 1800 milliseconds have passed in auton
		if(time1[T1] > 1800)
		{
			motor[waterwheel] = 127;
			motor[shooterConveyor] = 127;
		}
		if(time1[T1] > 8500 && time1[T1] < 9500)//red side of field
		{
			//make a different set point for different firing distance
			int newSp = 1400;
			//change flywheels to match that setpoint via PID
			outL = pidExecute(flywheelL, rpmAvgL, newSp);
			outR = pidExecute(flywheelR, rpmAvgR, newSp);
			driveFlywheelLeft(outL);
			driveFlywheelRight(outR);

			//using PID with gyroscope to turn and drive straight
			gyroTurn(-35);
			pidDrive(1000);
			//wait1Msec(10000);
			gyroTurn(75);
			clearTimer(T2);	//clearing timer T2 on Cortex

			//driving backwards and hitting the field wall, then forwards, then back
			while(time1[T2] < 800)
			{
				driveL(-127);
				driveR(-127);
			}
			while(time1[T2] < 1350)
			{
				driveL(127);
				driveR(127);
			}
			while(time1[T2] < 2150)
			{
				driveL(-127);
				driveR(-127);
			}

			pidDrive(180);
			gyroTurn(-33);
		}

		//similar code to above, just for the blue side of the field
		/*		if(time1[T1] > 8500 && time1[T1] < 9500)//blue side
		{
			int newSp = 1400;
			outL = pidExecute(flywheelL, rpmAvgL, newSp);
			outR = pidExecute(flywheelR, rpmAvgR, newSp);
			driveFlywheelLeft(outL);
			driveFlywheelRight(outR);
			gyroTurn(35);
			pidDrive(1000);
			//wait1Msec(10000);
			gyroTurn(-75);
			clearTimer(T2);
			while(time1[T2] < 800)
			{
				driveL(-127);
				driveR(-127);
			}
			while(time1[T2] < 1350)
			{
				driveL(127);
				driveR(127);
			}
			while(time1[T2] < 2150)
			{
				driveL(-127);
				driveR(-127);
			}
			pidDrive(180);
			gyroTurn(33);
		}*/

		/*Here we wait for 20 milliseconds, as if tasks do not have wait
		time in them, then they might not execute properly
		Include this command somewhere in the while loop of the task so it is executed
		on every iteration
		Most tasks don't need to run that often and can spend most of their time
		sleeping.
		Updating motors or checking sensors any more than 50 to 100 times a second is
		not necessary so an average task can have wait1Msec(20) at the end of the
		processing loop without any issues.
		From: http://www.robotc.net/wikiarchive/Multitasking_tips
		*/
		wait1Msec(20);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	pidDrive(1000);

	//clearing the debug stream for monitoring and graphing flywheel RPM
	//to tune the PID Loop
	debugStreamClear;

	//The target RPM for our flywheel (setpoint = sp)
	//It's also important to try different setpoints after you've tuned the
	//PID Loop, to make sure it's tuned well enough to work at different sp's
	//and to handle changes in sp.
	float sp = 1520; // old 1480

	pidInit(flywheelL, 0.3, 0.1, -0.00007, 3);	//NEW NEW BEST
	pidInit(flywheelR, 0.3, 0.1, -0.00007, 3);	//NEW NEW BEST


	//declaring some variables we'll use later
	unsigned long lastTime = nPgmTime;
	resetMotorEncoder(flywheelLeft1);
	resetMotorEncoder(flywheelRight1);
	bool runFlywheel = false;
	bool btn8DPressed = false;
	float rpmL, lastRpmL1, lastRpmL2, lastRpmL3, lastRpmL4;
	float rpmR, lastRpmR1, lastRpmR2, lastRpmR3, lastRpmR4;
	int counter = 0;

	//NOTES: Gear ratio now = 1:16.8

	while (true)
	{
		//Flywheel PID work:


		if(vexRT(Btn8D) == 1)
		{
			btn8DPressed = true;
		}
		if(btn8DPressed == true)
		{

			dT = (float)(nPgmTime - lastTime)/1000;
			lastTime = nPgmTime;

			if(dT != 0) //if time since our last reading is not 0
			{
				/*RPM Calculation
				The 7 is for an external gear ratio of 7:1 not being measured by the encoder
				(the encoder is attached to the gear right before the flywheel shaft at a
				7:1 ratio).
				The 60 is for 60 seconds in a minute (converts from rotations per second to per minute)
				We get the motor encoder current reading (so ticks since our last reset)
				We divide the ticks since last reset by the change in time since our last reading
				This gets us the number of ticks per second
				We divide the ticks per second by 360 (360 ticks per rotation) to get
				roatations per second
				*/
				//(internal gearing is handled by the /dT)
				rpmL = 60.00*7*(((float)getMotorEncoder(flywheelLeft1))/dT)/360;
				rpmR = 60.00*7*(((float)getMotorEncoder(flywheelRight1))/dT)/360;
			}
			else
			{
				rpmL = 0;
				rpmR = 0;
			}
			resetMotorEncoder(flywheelLeft1);
			resetMotorEncoder(flywheelRight1);

			//calculating the average RPM for each flywheel by using the last few readings
			lastRpmL4 = lastRpmL3;
			lastRpmL3 = lastRpmL2;
			lastRpmL2 = lastRpmL1;
			lastRpmL1 = rpmL;

			lastRpmR4 = lastRpmR3;
			lastRpmR3 = lastRpmR2;
			lastRpmR2 = lastRpmR1;
			lastRpmR1 = rpmR;

			rpmAvgL = (rpmL + lastRpmL1 + lastRpmL2 + lastRpmL3 + lastRpmL4)/5;
			rpmAvgR = (rpmR + lastRpmR1 + lastRpmR2 + lastRpmR3 + lastRpmR4)/5;

			//checking if the average RPM is within our desired range
			//increment our "stability" counter if so
			if(rpmAvgR >= sp-50 && rpmR <= sp+50 && rpmAvgL >= sp-50 && rpmL< sp+50)
			{
				counter++;
			}

			//if our "stability" counter has proven stable (is >=3) turn an LED on to
			//indicate flywheel is ready for firing!
			if(counter >= 3)
			{
				SensorValue(flywheelLED) = 1;
			}

			//if our stability counter is out of the range, counter is 0 (not stable)
			//turn flywheelLED off
			if(rpmAvgR < sp-150 || rpmR > sp+150 || rpmAvgL < sp-150 || rpmL > sp+150)
			{
				counter = 0;
				SensorValue(flywheelLED) = 0;
			}

			//integral cap  (keeps it capped at or below a value to keep it from sprialing
			//out of control)
			//THIS WON'T BE NEEDED FOR DOING DRIVING PID, only in use here becuase
			//This PID Loop is constantly running while the flywheel is going
			if(flywheelL.errorSum > 18000) // OLD: 20500    //OLD BEST = 18000,
			{
				flywheelL.errorSum = 18000;
			}
			if(flywheelR.errorSum > 18000)
			{
				flywheelR.errorSum = 18000;
			}

			//Calculate the output of the PID controller and output to drive motors
			//The pidExecute function is in PIDController.h
			outL = pidExecute(flywheelL, rpmAvgL, sp);
			outR = pidExecute(flywheelR, rpmAvgR, sp);

			//Button for turning the flywheel off
			if(vexRT(Btn8U) == 1)
			{
				btn8DPressed = false;
				outL = 0;
				outR = 0;
			}

			//Button for decreasing the flywheel's setpoint by 5 RPM
			//(The wait is there so that even if the driver's press is not
			//instantaneous the setpoint does not decrease unintentionally)
			if(vexRT(Btn8L) == 1)
			{
				sp -= 5;
				wait1Msec(500);
			}

			//Button for increasing the flywheel's setpoint by 5 RPM
			//(The wait is there so that even if the driver's press is not
			//instantaneous the setpoint does not increase unintentionally)
			if(vexRT(Btn8R) == 1)
			{
				sp += 5;
				wait1Msec(500);
			}

			//minimum motor speed
			if(outL < 1)
			{
				outL = 1;
			}
			//drive the left flywheel motors at the value calculated by the PID loop
			driveFlywheelLeft(outL);

			//minimum motor speed
			if(outR < 1)
			{
				outR = 1;
			}
			//drive the right flywheel motors at the value calculated by the PID loop
			driveFlywheelRight(outR);
		}

	  	//motors direct mapping from up/down joysticks
		motor[driveTrainRight] = vexRT[Ch2];
	  	motor[driveTrainLeft] = vexRT[Ch3];

	  	//conveyor sets
	  	int shooterConveyorOn = vexRT[Btn7D];
	  	int shooterConveyorOff = vexRT[Btn7U];
	  	int shooterConveyorOut = vexRT[Btn7R];

	  	//waterwheel sets
	  	int waterwheelIn = vexRT[Btn7DXmtr2]; //to use partner joystick append Xmtr2
		int waterwheelOff = vexRT[Btn7UXmtr2];
		int waterwheelOut = vexRT[Btn7RXmtr2];

		//flywheel sets
		int maxFlywheel = vexRT[Btn8D];
		int flywheelIncrement = vexRT[Btn8R];
		int flywheelDecrement = vexRT[Btn8L];
		int flywheelOff = vexRT[Btn8U];

		//ramp sets
		int rampLeftDown = vexRT[Btn5D];
		int rampLeftUp = vexRT[Btn5U];
		int rampRightDown = vexRT[Btn6D];
		int rampRightUp = vexRT[Btn6U];

		//waterwheel control code
		if(waterwheelIn == 1)
		{
			motor[waterwheel] = 127;
		}
		else if(waterwheelOut == 1)
		{
			motor[waterwheel] = -127;
		}
		else if(waterwheelOff == 1)
		{
			motor[waterwheel] = 0;
		}

		//shooter conveyor control code
		if(shooterConveyorOn == 1)
		{
			motor[shooterConveyor] = 127;
		}
		else if(shooterConveyorOut == 1)
		{
			motor[shooterConveyor] = -127;
		}
		else if(shooterConveyorOff == 1)
		{
			motor[shooterConveyor] = 0;
		}

		//ramp control code
		//allows independent control for each side
		if( rampLeftDown == 1)
		{
			motor[rampLeft] = 127;
		}
		else if( rampLeftUp == 1)
		{
			motor[rampLeft] = -127;
		}
		else
		{
			motor[rampLeft] = 0;
		}

		if( rampRightDown == 1)
		{
			motor[rampRight] = 127;
		}
		else if( rampRightUp == 1)
		{
			motor[rampRight] = -127;
		}
		else
		{
			motor[rampRight] = 0;
		}

		//Outputting the right flywheel RPM for debug and graphing/logging purposes
		writeDebugStreamLine("%f", rpmR);

		/*Here we wait for 20 milliseconds, as if tasks do not have wait
		time in them, then they might not execute properly
		Include this command somewhere in the while loop of the task so it is executed
		on every iteration
		Most tasks don't need to run that often and can spend most of their time
		sleeping.
		Updating motors or checking sensors any more than 50 to 100 times a second is
		not necessary so an average task can have wait1Msec(20) at the end of the
		processing loop without any issues.
		From: http://www.robotc.net/wikiarchive/Multitasking_tips
		*/
		wait1Msec(20);
	}
}